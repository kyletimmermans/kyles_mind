/* 

If we go through a list of strings once, where each unique string
value is "better" than another and we need to determine
by the end of the list, which is the best value we have in the list,
we can give each string a numerical value to actually compare them
to determine the "best" string we have.

By using an algorithm that looks for the largest value in a list,
we can apply it to our strings that have numerical values and thus
pull out the string that is the most important (the one with the largest
numerical value) 

So if we have the list:

{"jpg", "png", "jpg", "svg", "png", "ico"}

Where "ico" is best, followed by "png", followed by "svg", and then
"jpeg" which is the worst, we can apply numerical values to each:

"ico" - 3, "png" - 2, "svg" - 1, "jpg" - 0

Now we can use the '>' operator to actually compare the "betterness"
of strings as we can't compare the "betterness" of strings on their
own.

What is being done below is just a for-loop that is keeping track
of the greatest rank and then comparing it to the next values and changing 
it to the next biggest one it finds until we get to the end, thus, leaving
us with the biggest or in our case, the "best" value.

*/

// Generated by ChatGPT-4
package main

import "fmt"

func main() {
	valuesList := []string{"jpg", "png", "jpg", "svg", "png", "ico"}

	bestValue := findBest(valuesList)
	fmt.Println("Best value:", bestValue) // Output: "Best value: ico"
}

func findBest(values []string) string {
	bestRank := -1
	bestValue := ""

	for _, value := range values {
		rank := getRank(value)
		if rank > bestRank {
			bestRank = rank
			bestValue = value
		}
	}

	return bestValue
}

func getRank(value string) int {
	switch value {
	case "ico":
		return 3
	case "png":
		return 2
	case "svg":
		return 1
	case "jpg":
		return 0
	default:
		return -1
	}
}